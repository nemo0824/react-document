## React가 컴포넌트와 hook 호출하는 방식

React는 사용자 경험을 최적화하기 위해 필요할 때마다 컴포넌트와 hook을 렌더링하는 역할을 한다.
"선언적"

### 컴포넌트 함수를 직접 호출하지 말것

- React는 렌더링하는동안 컴포넌트 함수가 언제 호출될지 결정 JSX로 수행
- 컴포넌트가 함수 이상의 역할을 하게됨
- 컴포넌트 타입이 재조정 과정을 참여
- React가 사용자 경험을 향상 시킬수있다.
- 더 나은 디버깅 제공
- 재조정 과정 효율적

### hook을 일반값 처럼 전달하지 말것

- 동적으로 변경하지말것.

## hook의 규칙

### hook을 최상위 레벨에서만 호출

### hook을 React함수에서만 호출(hook 또는 함수형 컴포넌트에서만 호출)

- hook은 React가 함수 컴포넌트를 렌더링하는 동안 만 호출할 수 있다. (조건문, 반복문, try, catch,) 블록내부에서 호출 불가

### Context

보통의 경우 부모 컴포넌트에서 자식 컴포넌트로 props를 통해 정보를 전달
중간에 많은 컴포넌트를 거쳐야하거나, 애플리케이션의 많은 컴포넌트에서 동일한 정보가 필요한경우에는 props를 전달하는것이 번거롭고 불편할수있다

context 사용전 고려해야할것

1. props로 전달
2. 컴포넌트를 추출하고 jsx를 children으로 전달하기.

### useCallback

useCallback은 함수 자체를 캐싱
useMemo와 달리, 전달한 함수를 호출하지 않습니다.
그대신 전달한 함수를 캐싱해서 의존성의 값이 변하지않으면 해당 함수 자체가 변하지않도록합니다.
이것은 불필요하게 자식을 리렌더링하지않고 캐싱한 함수를 전달할수 있도록 도와줍니다.
함수의 코드는 사용자가 폼을 제출하기전까지 실행되지않는다

### useMemo 꼭 사용해야할까?

사용하지않아도되는경우
굵직한 상호작용이 필요한경우 ex) 페이지 전체나 전체 부문을 교체하는것

사용하면 좋은경우
미세한 상호작용일경우 ex) 도형이 이동하는것

결론
굳이 매번 사용할필요가없고 꼭 필요한곳에서 사용할것
react developer tools 사용해서 어떤 컴포넌트가 가장 필요한지 살펴보고 해당 하는곳에 사용할것.

### useMemo

useMemo는 호출한 함수의 결과값을 캐싱합니다.
함숲호출결과를 캐싱해서 의존성이 변하지않는한 결과값이 변경되지않도록합니다.
불필요하게 자식요소를 리렌더링하지않고 결과값을 넘길수있도록합니다

### React Fiber tree

Fiber tree
React는 렌더링 최적화하기위해 Fiber라는 구조체를 사용

Fiber는 React 컴포넌트의 작업단위
각각 컴포넌트는 하나의 Fiber Node로 표현

```
function AComponent(){
const [cout, setCount] = useState(0);
const [name, setName] = useState("LIM")
useEffect(()=> {
console.log("effect")
},[])
}
```

Acomponent Fiber Node
-> hooks
-> Hook 1: {memoizedState: 0}
-> Hook 2: {memoizedState: "LIM"}
-> Hook 3: {tag: Effect, deps: []}

내부적으로 linked list로 연결 순서 보장이 매우 중요.
훅을 조건문에서 쓰면안되는 이유 => 순서가 틀어지면 React가 어떤상태인지 알 수 없게됨

Fiber 의 도입 배경
기존 virtual dom 의 문제점

- 렌더링 중간에 중단 불가 (동기적 처리만가능)
- 트리가 클수록 렌더링이 오래걸린다.
- 렌더링 오래걸리는경우, 사용자 이벤트 블로킹 발생

React 16 부터

- fiber도입 -> 각작업을 작은 단위로 쪼개어 처리
- 사용자 인터렉션, 애니메이션 등의 우선순위 기반 스케줄링 가능
- 작업 중단 가능
- 각 노드 독립적인 작업단위로 처리
